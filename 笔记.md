# WebServer学习笔记



## C++ 11之后的新功能

#### std::future

我们想要从线程中返回异步任务结果，一般需要依靠**全局变量**；从安全角度看，有些不妥；为此C++11提供了std::future类模板，**future对象提供访问异步操作结果的机制**，很轻松解决从异步任务中返回结果。



#### Using typename

```c++
using return_type=typename std::result_of<F(Args...)>:: type;
//这里的typename是为了说明后面是个类型,因为后面是个嵌套从属类型
```



#### std::result_of
用于在编译的时候推导出一个可调用对象（函数,std::funciton或者重载了operator()操作的对象等）的返回值类型.主要用于模板编写中.



#### std::optional——C++17
std::optional<具体类型> 是一个包含0或1个元素的容器。作为返回值可以是返回**std::nullopt**，也可以是返回**具体类型**。



#### std::tuple

std::tuple是类似pair的模板。每个pair的成员类型都不相同，但每个pair都恰好有两个成员。不同std::tuple类型的成员类型也不相同，但**一个std::tuple可以有任意数量的成员**。每个确定的std::tuple类型的成员数目是固定的，但一个std::tuple类型的成员数目可以与另一个std::tuple类型不同。
但我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，std::tuple是非常有用的。我们可以将std::tuple看作一个”快速而随意”的数据结构。



#### bind

```c++
auto newCallable = bind(callable,arg_list);
```

arg_list中的参数可能包含形如n的名字，其中n是一个整数，这些参数是“占位符”，表示**newCallable的参数**，它们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：\_1为newCallable的第一个参数，_2为第二个参数，以此类推。

在**WEBSERVER**项目写线程池时，主要目的就是**把很多类型不同的函数都包装成 void name () 类型，用于模板编程，提高复用性。**



#### std::packaged_task

简单来说std::packaged_task<F>是对可调对象(如函数、lambda表达式等)进行了包装，并将这一可调对象的返回结果传递给关联的std::future对象。

```c++
#include<functional>
#include<future>
#include<thread>
#include<iostream>

int test(int a)
{
    a+=10;
    return a;
}

int main()
{
    std::packaged_task<int(int)> fun1(test);
    std::future<int> res=fun1.get_future();
    
    std::thread t1(fun1,100);//切记：传入线程中的是pack打包好的函数。而不是上面那个。
    
    std::cout<<res.get()<<std::endl;
    return 0;
    
}
```





std::forward

待看————Effective Modern C++ 关于完美转发的内容



#### std::chrono

代表时间。常用手段：**std::chrono::seconds(5);**



   #### atomic原子量

在头文件\<atomic>，保证对变量的操作都是原子操作。

使用方法：

```c++
#include<atomic>
std::atomic<int> a=0;
```



#### mutex互斥量

在头文件\<mutex>中。

使用方法

```c++
#include<mutex>

std::mutex mtx1;
mtx1.lock();
a++;//若在临界区return或者抛出异常，则有可能死锁
mtx1.unlock();

//解决方法，使用std::unique_lock，若在临界区return或者抛出异常，则会自动析构

//注意并不是unique_mutex.
std::unique_lock<std::mutex> lock(mtx1);//构造函数需要传一个mutex，这一步实际上已经上锁
lock.unlock();//解锁

```



#### 条件变量

在头文件\<condition_variable>中

使用方法：

```c++
#include<thread>
#include<iostream>
#include<chrono>
#include<queue>
#include<mutex>
#include<condition_variable>

std::queue<int> q;//工作队列
std::mutex mtx1;
int i=0;
std::condition_variable cv;

void consumer()
{
    while(1)
    {
        if(q.size())
        {
            std::unique_lock<std::mutex> lock(mtx1);

            while(q.empty())//要使用while，否则可能虚假唤醒
            {
                cv.wait(lock);//wait时会释放锁
            }
            int t=q.front();
            q.pop();
            std::cout<<t<<std::endl;
        }
    }
}

void producer()
{
    while(1)
    {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::unique_lock<std::mutex> lock(mtx1);
        q.push(i++);
        cv.notify_one();//唤醒一个线程
    }
}

int main()
{
    std::thread Cosu(consumer);
    std::thread Produ(producer);
    Cosu.join();
    Produ.join();
    return 0;
}

```



#### 虚假唤醒

假设是在等待消费队列，一个线程A被nodify，但是还没有获得锁时，另一个线程B获得了锁，并消费掉了队列中的数据。B退出或wait后，A获得了锁，而这时条件已不满足。



#### 信号量

```c++
#include<iostream>
#include<semaphore>
#include<thread>

std::counting_semaphore<4> csem(0);
std::binary_semaphore bsem(0);

void func()
{
    std::cout<<"thread want to get the semaphore !"<<std::endl;
    csem.acquire();
    std::cout<<"thread get !"<<std::endl;
}

int main()
{
    std::thread task1(func);
    std::thread task2(func);
    std::thread task3(func);
    std::thread task4(func);
    
    std::cout<<"semaphore is ready to release 2 !"<<std::endl;
    csem.release(2);
    std::cout<<"semaphore has been released !"<<std::endl;
    
    task1.join();
    task2.join();
    task3.join();
    task4.join();
}
```



#### std::call_once

某些场景下，我们需要代码只被执行一次，比如单例类的初始化，考虑到多线程安全，需要进行加锁控制。C++11中提供的call_once可以很好的满足这种需求，使用又非常简单。

```c++
#include<mutex>

template <class Fn, class... Args>

void call_once (std::once_flag& flag, Fn&& fn, Args&&...args);
```

第一个参数是std::once_flag的对象(once_flag是不允许修改的，其拷贝构造函数和operator=函数都声明为delete)，第二个参数可调用实体，即要求只执行一次的代码，后面可变参数是其参数列表。







## 一些知识点

#### g++支持C++20

在编译时，末尾加上-std=c++20



#### emplace_back和push_back的区别

push_back：在引入右值引用，转移构造函数，转移复制运算符之前，通常使用push_back()向容器中加入一个右值元素（临时对象）的时候，首先会调用构造函数**构造这个临时对象**，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的**临时变量释放**。这样造成的问题是临时变量申请的**资源就浪费**。push_back括号里面是对象，以该对象拷贝构造。

emplace_back：在容器尾部添加一个元素，这个元素**原地构造**，不需要触发拷贝构造和转移构造。而且调用形式更加简洁，直接根据参数初始化临时对象的成员。emplace_back括号里面是参数，以该参数原地构造。



#### 信号处理方式——同步处理与异步处理

在Linux的**多线程中使用信号机制**，与在进程中使用信号机制有着根本的区别，可以说是完全不同。在进程环境中，对信号的处理是，先注册信号处理函数，当信号异步发生时，调用处理函数来处理信号。它完全是异步的（我们完全不知到信号会在进程的那个执行点到来！）。然而信号处理函数的实现，有着许多的限制；比如有一些函数不能在信号处理函数中调用；再比如一些函数read、recv等调用时会被异步的信号给中断(interrupt)，因此我们必须对在这些函数在调用时因为信号而中断的情况进行处理（判断函数返回时 enno 是否等于 EINTR）。



但是在多线程中处理信号的原则却完全不同，它的基本原则是：将对信号的异步处理，转换成同步处理，也就是说**用一个线程专门的来“同步等待”信号的到来，而其它的线程可以完全不被该信号中断/打断(interrupt)**。这样就在相当程度上简化了在多线程环境中对信号的处理。而且可以保证其它的线程不受信号的影响。这样我们对信号就可以完全预测，因为它不再是异步的，而是同步的（我们完全知道信号会在哪个线程中的哪个执行点到来而被处理！）。而同步的编程模式总是比异步的编程模式简单。其实多线程相比于多进程的其中一个优点就是：多线程可以将进程中异步的东西转换成同步的来处理。

sigwait是**同步**的等待信号的到来，而不是像进程中那样是异步的等待信号的到来。sigwait函数使用一个信号集作为他的参数，并且在集合中的任一个信号发生时返回该信号值，**解除阻塞**，然后可以针对该信号进行一些相应的处理。



调用sigwait同步等待的信号必须在调用线程中被屏蔽，并且通常应该在所有的线程中被屏蔽（这样可以保证信号绝不会被送到除了调用sigwait的任何其它线程），这是通过利用信号掩码的继承关系来达到的。



#### 为什么监听socket一定要是非阻塞的

（前提是采用了IO复用函数）

当一个连接到来的时候，监听套接字可读，此时，我们稍微等一段时间之后再调用accept()。就在这段时间内，客户端**设置linger选项(l_onoff = 1, l_linger = 0)**，然后**调用了close()**，那么客户端将不经过四次挥手过程，通过发送**RST报文**断开连接。服务端接收到RST报文，系统会将排队的这个未完成连接直接删除，此时就相当于没有任何的连接请求到来， 而**接着调用的accept()将会被阻塞**，直到另外的新连接到来时才会返回。这是与IO多路复用的思想相违背的**(系统不阻塞在某个具体的IO操作上，而是阻塞在select、poll、epoll这些IO复用上的)**。

上述这种情况下，**如果监听套接字为非阻塞的，accept()不会阻塞住，立即返回-1，同时errno = EWOULDBLOCK。**





#### Epoll在使用ET模式时，为什么要把监听的套接字设为非阻塞模式？

如果多个连接同时到达，ET模式下就只会通知一次，为了处理剩余的连接数，必须要时刻accpet 句柄，直到出现errno为EAGAIN, 出于这样的目的的话，socket也要设置为非阻塞



#### socket客户端连接上服务端是在listen之后而非在accept之时

在listen后，客户端就可以与服务器进行连接（TCP三次握手），此时的连接结果放在队列中。服务端知乎调用 accept() 函数从队列中获取一个已准备好的连接，函数返回一个新的 socket ,新的 socket 用于与客户端通信，listen 的 socket 只负责监听客户端的连接请求。









#### 项目中的细节

##### 时间器时间更改的几个节点

1、建立连接时，时间器定时为header_time，Epoll



2、分析到post请求时，判断数据是否完整前，时间器更改为body_time



3、完成发送后，重置时间：如果为长连接，重置时间为keep_alive_time。如果是短连接，则删除is_conn事件，并删除时间器。





## BUG



### 1

C++的类体中，方法以外的区域不允许有初始化，简单类型是可以的，但是有构造函数的复杂对象则不行了，比如string对象！

```cpp
class A
{    
     vector<string> v(9);  //error,expected identifier before numeric constant
public:
     void test(){}
};
```



### 2

定义全局变量时使用static，意味着该变量的作用域只限于定义它的**源文件**中，其它源文件不能访问。如果这种定义方式出现在头文件中，那么可以很自然地推测：**包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次**。



### 3

string += 时，后面不能一直加 “ ”形式的字符串，从第二个开始要显式地定义类型。

